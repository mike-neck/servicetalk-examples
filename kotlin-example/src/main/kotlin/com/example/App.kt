/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.example

import io.servicetalk.concurrent.api.Single
import io.servicetalk.data.jackson.JacksonSerializationProvider
import io.servicetalk.http.api.*
import io.servicetalk.http.netty.HttpServers
import io.servicetalk.http.router.predicate.HttpPredicateRouterBuilder
import io.servicetalk.serialization.api.TypeHolder
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.lang.NumberFormatException

fun main() {
  val service = Service(DefaultMapRepository)
  val controller = RecordController(service)
  val adapter = ControllerAdapter(controller,
      HttpSerializationProviders.jsonSerializer(JacksonSerializationProvider()))

  HttpServers.forPort(8080)
      .listenStreamingAndAwait(route(adapter))
      .awaitShutdown()
}

private fun route(adapter: ControllerAdapter): StreamingHttpService {
  return HttpPredicateRouterBuilder()
      .whenMethod(HttpRequestMethod.GET)
      .andPathMatches("/api/\\p{N}+")
      .thenRouteTo(HttpService { ctx, request, responseFactory -> adapter.get(ctx, request, responseFactory) })
      .buildStreaming()
}

enum class Distance {
  FIVE_KM,
  TEN_KM,
  FIFTEEN_KM,
  TWENTY_KM,
  HALF_MARATHON,
  ;
}

data class Record(val id: Int, val distance: Distance, val time: Int) {
  constructor(id: Int, distance: Distance, hour: Int, min: Int, sec: Int): this(id, distance, (hour * 60 + min) * 60 + sec)

  companion object {
    fun fiveKm(id: Int, min: Int, sec: Int): Record = Record(id, Distance.FIVE_KM, 0, min, sec)
    fun tenKm(id: Int, min: Int, sec: Int): Record = Record(id, Distance.TEN_KM, 0, min, sec)
    fun fifteenKm(id: Int, min: Int, sec: Int): Record = Record(id, Distance.FIFTEEN_KM, 0, min, sec)
    fun twentyKm(id: Int, hour: Int, min: Int, sec: Int): Record = Record(id, Distance.TWENTY_KM, hour, min, sec)
    fun halfMarathon(id: Int, hour: Int, min: Int, sec: Int): Record = Record(id, Distance.HALF_MARATHON, hour, min, sec)
  }
}

interface RecordRepository {
  fun findById(id: Int): Record?
}

class Service(private val repository: RecordRepository) {

  fun findById(id: Int): Record? = repository.findById(id)
}

object DefaultMapRepository: RecordRepository {

  private val map: Map<Int, Record> = mapOf(
      1 to Record.fiveKm(1, 15, 31),
      2 to Record.tenKm(2, 31, 11),
      3 to Record.fifteenKm(3, 46, 7),
      4 to Record.twentyKm(4, 1, 2, 24),
      5 to Record.halfMarathon(5, 1, 6, 3)
  )

  override fun findById(id: Int): Record? = map[id]
}

interface ResponseShape<T: Any> {
  val status: Int
  val contentType: String
  val body: T
  fun serializer(serializationProvider: HttpSerializationProvider): HttpSerializer<T>

  fun prepareBuilder(factory: HttpResponseFactory): HttpResponse =
      if (status == 200) factory.ok() else if (status == 400) factory.notFound() else factory.internalServerError()
}

class Response<T: Any>(override val status: Int, override val contentType: String, override val body: T, val klass: Class<T> = body.javaClass): ResponseShape<T> {
  override fun serializer(serializationProvider: HttpSerializationProvider): HttpSerializer<T> = serializationProvider.serializerFor(klass)
}

class Res<T: Any>(override val status: Int, override val contentType: String, override val body: T, val type: TypeHolder<T>): ResponseShape<T> {
  override fun serializer(serializationProvider: HttpSerializationProvider): HttpSerializer<T> = serializationProvider.serializerFor(type)
}

object MapType: TypeHolder<Map<String, String>>()

class RecordController(private val service: Service) {
  fun findById(id: Int): ResponseShape<*> =
      service.findById(id)
          ?.let { Response(200, "application/json", it) }
          ?: Res(404, "application/json", mapOf("message" to "not found record of id: $id"), MapType) as ResponseShape<*>
}

fun String.asInt(): Int? = try {
  this.toInt()
} catch (e: NumberFormatException) {
  null
}

class ControllerAdapter(
    private val controller: RecordController,
    private val serializationProvider: HttpSerializationProvider,
    private val logger: Logger = LoggerFactory.getLogger(ControllerAdapter::class.java)) {
  
  fun get(context: HttpServiceContext, request: HttpRequest, responseFactory: HttpResponseFactory): Single<HttpResponse> {
    logger.info("request path: ${request.path()}")
    val split = request.path().split("/")
    if (split.size < 2) return Single.succeeded(responseFactory.notFound().addHeader("content-type", "application/json").payloadBody(mapOf("message" to "not found"), serializationProvider.serializerFor(MapType)))
    val id: Int = split[2].asInt() ?: return Single.succeeded(responseFactory.notFound().addHeader("content-type", "application/json").payloadBody(mapOf("message" to "not found"), serializationProvider.serializerFor(MapType)))
    val response = controller.findById(id)

    @Suppress("UNCHECKED_CAST")
    val httpResponse = response.prepareBuilder(responseFactory).addHeader("content-type", response.contentType).payloadBody(response.body, response.serializer(serializationProvider) as HttpSerializer<Any>)
    return Single.succeeded(httpResponse)
  }
}
